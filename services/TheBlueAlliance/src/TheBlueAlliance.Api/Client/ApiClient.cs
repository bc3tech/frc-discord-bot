/*
 * The Blue Alliance API v3
 *
 * # Overview    Information and statistics about FIRST Robotics Competition teams and events.   # Authentication   All endpoints require an Auth Key to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth key yet, you can obtain one from your [Account Page](/account).
 *
 * The version of the OpenAPI document: 3.9.7
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

namespace TheBlueAlliance.Api.Client;

using Common;

using Polly;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// To Serialize/Deserialize JSON using our custom logic, but only when ContentType is JSON.
/// </summary>
internal partial class CustomJsonCodec
{
    private readonly IReadableConfiguration _configuration;

    private readonly JsonSerializerOptions _serializerSettings = new()
    {
        // OpenAPI generated types generally hide default constructors.
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
    };

    public CustomJsonCodec(IReadableConfiguration configuration)
    {
        _configuration = configuration;
    }

    public CustomJsonCodec(JsonSerializerOptions serializerSettings, IReadableConfiguration configuration)
    {
        _serializerSettings = serializerSettings;
        _configuration = configuration;
    }

    /// <summary>
    /// Serialize the object into a JSON string.
    /// </summary>
    /// <param name="obj">object to be serialized.</param>
    /// <returns>A JSON string.</returns>
    public string Serialize(object obj)
    {
        if (obj is Model.AbstractOpenAPISchema openApiSchema)
        {
            // the object to be serialized is an oneOf/anyOf schema
            return openApiSchema.ToJson();
        }
        else
        {
            return JsonSerializer.Serialize(obj, _serializerSettings);
        }
    }

    public async Task<T> DeserializeAsync<T>(HttpResponseMessage response, CancellationToken cancellationToken = default)
    {
        var result = (T)await DeserializeAsync(response, typeof(T), cancellationToken).ConfigureAwait(false);
        return result;
    }

    /// <summary>
    /// Deserialize the JSON string into a proper object.
    /// </summary>
    /// <param name="response">The HTTP response.</param>
    /// <param name="type">object type.</param>
    /// <param name="cancellationToken"></param>
    /// <returns>object representation of the JSON string.</returns>
    internal async Task<object> DeserializeAsync(HttpResponseMessage response, Type type, CancellationToken cancellationToken = default)
    {
        IList<string> headers = [.. response.Headers.Select(x => x.Key + "=" + x.Value)];

        if (type == typeof(byte[])) // return byte array
        {
            return await response.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
        }
        else if (type == typeof(FileParameter))
        {
            return new FileParameter(await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false));
        }

        // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
        if (type == typeof(Stream))
        {
            var bytes = await response.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
            if (headers is not null)
            {
                var filePath = string.IsNullOrEmpty(_configuration.TempFolderPath)
                    ? Path.GetTempPath()
                    : _configuration.TempFolderPath;
                var regex = MyRegex();
                foreach (var header in headers)
                {
                    var match = regex.Match(header.ToString());
                    if (match.Success)
                    {
                        string fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value.Replace("\"", "").Replace("'", ""));
                        File.WriteAllBytes(fileName, bytes);
                        return new FileStream(fileName, FileMode.Open);
                    }
                }
            }

            var stream = new MemoryStream(bytes);
            return stream;
        }

        if (type.Name.StartsWith("System.Nullable`1[[System.DateTime", StringComparison.OrdinalIgnoreCase)) // return a datetime object
        {
            return DateTime.Parse(await response.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false), null, System.Globalization.DateTimeStyles.RoundtripKind);
        }

        if (type == typeof(string) || type.Name.StartsWith("System.Nullable", StringComparison.OrdinalIgnoreCase)) // return primitive type
        {
            return Convert.ChangeType(await response.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false), type);
        }

        // at this point, it must be a model (json)
        try
        {
            return Throws.IfNull(JsonSerializer.Deserialize(await response.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false), type, _serializerSettings));
        }
        catch (Exception e)
        {
            throw new ApiException(500, e.Message);
        }
    }

    public string? RootElement { get; set; }
    public string? Namespace { get; set; }
    public string? DateFormat { get; set; }

    public string ContentType { get; } = "application/json";

    [GeneratedRegex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$")]
    private static partial Regex MyRegex();
}
/// <summary>
/// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
/// encapsulating general REST accessor use cases.
/// </summary>
/// <remarks>
/// The Dispose method will manage the HttpClient lifecycle when not passed by constructor.
/// </remarks>
public partial class ApiClient(IHttpClientFactory clientFactory, HttpClientHandler? httpClientHandler = null) : IAsynchronousClient
{
    public const string HttpClientKey = "TheBlueAlliance";
    private readonly HttpClient _httpClient = clientFactory.CreateClient(HttpClientKey);

    /// <summary>
    /// Specifies the settings on a <see cref="JsonSerializer" /> object.
    /// These settings can be adjusted to accommodate custom serialization rules.
    /// </summary>
    public JsonSerializerOptions SerializerSettings { get; set; } = new JsonSerializerOptions
    {
        // OpenAPI generated types generally hide default constructors.
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
    };

    /// Prepares multipart/form-data content
    static MultipartFormDataContent PrepareMultipartFormDataContent(RequestOptions options)
    {
        string boundary = "---------" + Guid.NewGuid().ToString().ToUpperInvariant();
        var multipartContent = new MultipartFormDataContent(boundary);
        foreach (var formParameter in options.FormParameters)
        {
            multipartContent.Add(new StringContent(formParameter.Value), formParameter.Key);
        }

        if (options.FileParameters is not null && options.FileParameters.Count > 0)
        {
            foreach (var fileParam in options.FileParameters)
            {
                foreach (var file in fileParam.Value)
                {
                    var content = new StreamContent(file.Content);
                    content.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
                    multipartContent.Add(content, fileParam.Key, file.Name);
                }
            }
        }

        return multipartContent;
    }

    /// <summary>
    /// Provides all logic for constructing a new HttpRequestMessage.
    /// At this point, all information for querying the service is known. Here, it is simply
    /// mapped into the a HttpRequestMessage.
    /// </summary>
    /// <param name="method">The http verb.</param>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>[private] A new HttpRequestMessage instance.</returns>
    /// <exception cref="ArgumentNullException"></exception>
    private HttpRequestMessage NewRequest(
        HttpMethod method,
        string path,
        RequestOptions options,
        IReadableConfiguration configuration)
    {
        ArgumentNullException.ThrowIfNull(path);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(configuration);

        WebRequestPathBuilder builder = new(_httpClient.BaseAddress?.ToString() ?? string.Empty, path);

        builder.AddPathParameters(options.PathParameters);

        builder.AddQueryParameters(options.QueryParameters);

        HttpRequestMessage request = new(method, builder.GetFullUri());

        if (configuration.UserAgent is not null)
        {
            request.Headers.TryAddWithoutValidation("User-Agent", configuration.UserAgent);
        }

        if (configuration.DefaultHeaders is not null)
        {
            foreach (var headerParam in configuration.DefaultHeaders)
            {
                request.Headers.Add(headerParam.Key, headerParam.Value);
            }
        }

        if (options.HeaderParameters is not null)
        {
            foreach (var headerParam in options.HeaderParameters)
            {
                foreach (var value in headerParam.Value)
                {
                    // Todo make content headers actually content headers
                    request.Headers.TryAddWithoutValidation(headerParam.Key, value);
                }
            }
        }

        List<Tuple<HttpContent, string, string>> contentList = [];

        string? contentType = null;
        if (options.HeaderParameters.TryGetValue("Content-Type", out var contentTypes) is true)
        {
            contentType = contentTypes.FirstOrDefault();
        }

        if (contentType is "multipart/form-data")
        {
            request.Content = PrepareMultipartFormDataContent(options);
        }
        else if (contentType is "application/x-www-form-urlencoded")
        {
            request.Content = new FormUrlEncodedContent(options.FormParameters);
        }
        else
        {
            if (options.Data is not null)
            {
                if (options.Data is FileParameter fp)
                {
                    contentType ??= "application/octet-stream";

                    var streamContent = new StreamContent(fp.Content);
                    streamContent.Headers.ContentType = new MediaTypeHeaderValue(contentType);
                    request.Content = streamContent;
                }
                else
                {
                    var serializer = new CustomJsonCodec(SerializerSettings, configuration);
                    request.Content = new StringContent(serializer.Serialize(options.Data), new UTF8Encoding(),
                        "application/json");
                }
            }
        }

        // TODO provide an alternative that allows cookies per request instead of per API client
        if (options.Cookies is not null && options.Cookies.Count > 0)
        {
            ((IDictionary<string, object?>)request.Options)["CookieContainer"] = options.Cookies;
        }

        return request;
    }

    partial void InterceptRequest(HttpRequestMessage req);
    partial void InterceptResponse(HttpRequestMessage req, HttpResponseMessage response);

    private async Task<ApiResponse<T>> ToApiResponseAsync<T>(HttpResponseMessage response, object responseData, Uri uri, CancellationToken cancellationToken = default)
    {
        T result = (T)responseData;
        string rawContent = await response.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

        var transformed = new ApiResponse<T>(response.StatusCode, [], result, rawContent)
        {
            ErrorText = response.ReasonPhrase,
            Cookies = []
        };

        // process response headers, e.g. Access-Control-Allow-Methods
        if (response.Headers is not null)
        {
            foreach (var responseHeader in response.Headers)
            {
                transformed.Headers.Add(responseHeader.Key, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        // process response content headers, e.g. Content-Type
        if (response.Content.Headers is not null)
        {
            foreach (var responseHeader in response.Content.Headers)
            {
                transformed.Headers.Add(responseHeader.Key, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        if (httpClientHandler is not null && response is not null)
        {
            try
            {
                foreach (Cookie cookie in httpClientHandler.CookieContainer.GetCookies(uri))
                {
                    transformed.Cookies.Add(cookie);
                }
            }
            catch (PlatformNotSupportedException) { }
        }

        return transformed;
    }

    private async Task<ApiResponse<T>> ExecAsync<T>(HttpRequestMessage req,
        IReadableConfiguration configuration,
        CancellationToken cancellationToken = default)
    {
        CancellationTokenSource? timeoutTokenSource = null;
        CancellationTokenSource? finalTokenSource = null;
        var deserializer = new CustomJsonCodec(SerializerSettings, configuration);
        var finalToken = cancellationToken;

        try
        {
            if (configuration.Timeout > 0)
            {
                timeoutTokenSource = new CancellationTokenSource(configuration.Timeout);
                finalTokenSource = CancellationTokenSource.CreateLinkedTokenSource(finalToken, timeoutTokenSource.Token);
                finalToken = finalTokenSource.Token;
            }

            if (configuration.Proxy is not null)
            {
                if (httpClientHandler is null)
                {
                    throw new InvalidOperationException("Configuration `Proxy` not supported when the client is explicitly created without an HttpClientHandler, use the proper constructor.");
                }

                httpClientHandler.Proxy = configuration.Proxy;
            }

            if (configuration.ClientCertificates is not null)
            {
                if (httpClientHandler is null)
                {
                    throw new InvalidOperationException("Configuration `ClientCertificates` not supported when the client is explicitly created without an HttpClientHandler, use the proper constructor.");
                }

                httpClientHandler.ClientCertificates.AddRange(configuration.ClientCertificates);
            }

            if (req.Options.TryGetValue(new HttpRequestOptionsKey<List<Cookie>>("CookieContainer"), out var cookieContainer) && cookieContainer is not null)
            {
                if (httpClientHandler is null)
                {
                    throw new InvalidOperationException("Request property `CookieContainer` not supported when the client is explicitly created without an HttpClientHandler, use the proper constructor.");
                }

                foreach (var cookie in cookieContainer)
                {
                    httpClientHandler.CookieContainer.Add(cookie);
                }
            }

            InterceptRequest(req);

            HttpResponseMessage response;
            if (RetryConfiguration.AsyncRetryPolicy is not null)
            {
                var policy = RetryConfiguration.AsyncRetryPolicy;
                var policyResult = await policy
                    .ExecuteAndCaptureAsync(() => _httpClient.SendAsync(req, finalToken))
                    .ConfigureAwait(false);
                response = (policyResult.Outcome == OutcomeType.Successful) ?
                    policyResult.Result : new HttpResponseMessage()
                    {
                        ReasonPhrase = policyResult.FinalException.ToString(),
                        RequestMessage = req
                    };
            }
            else
            {
                response = await _httpClient.SendAsync(req, finalToken).ConfigureAwait(false);
            }

            if (!response.IsSuccessStatusCode)
            {
                return await ToApiResponseAsync<T>(response, default(T), req.RequestUri).ConfigureAwait(false);
            }

            object responseData = await deserializer.DeserializeAsync<T>(response, cancellationToken).ConfigureAwait(false);

            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
            {
                responseData = (T)typeof(T).GetMethod("FromJson").Invoke(null, [response.Content]);
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                responseData = (T)(object)await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            }

            InterceptResponse(req, response);

            return await ToApiResponseAsync<T>(response, responseData, req.RequestUri).ConfigureAwait(false);
        }
        catch (OperationCanceledException original)
        {
            if (timeoutTokenSource is not null && timeoutTokenSource.IsCancellationRequested)
            {
                throw new TaskCanceledException($"[{req.Method}] {req.RequestUri} was timeout.",
                    new TimeoutException(original.Message, original));
            }

            throw;
        }
        finally
        {
            if (timeoutTokenSource is not null)
            {
                timeoutTokenSource.Dispose();
            }

            if (finalTokenSource is not null)
            {
                finalTokenSource.Dispose();
            }
        }
    }

    #region IAsynchronousClient
    /// <summary>
    /// Make a HTTP GET request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP POST request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP PUT request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP DELETE request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP HEAD request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP OPTION request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP PATCH request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null, CancellationToken cancellationToken = default)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(new HttpMethod("PATCH"), path, options, config), config, cancellationToken);
    }
    #endregion IAsynchronousClient
}
